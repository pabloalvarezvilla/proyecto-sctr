{\rtf1\ansi\ansicpg1252\cocoartf2867
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww28600\viewh18000\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 ## Descripci\'f3n t\'e9cnica del proyecto\
\
MiniPark es un sistema embebido de asistencia al aparcamiento implementado sobre una placa Raspberry Pi Pico y programado en lenguaje C utilizando el SDK oficial. \
El sistema utiliza un sensor de ultrasonidos HC-SR04 para medir la distancia hasta un obst\'e1culo y, en funci\'f3n de dicha distancia, activa diferentes combinaciones de LEDs y un zumbador para indicar el nivel de riesgo de colisi\'f3n.\
\
La placa Raspberry Pi Pico controla el pin TRIG del HC-SR04 para generar el pulso de disparo y mide el tiempo de vuelo del eco a trav\'e9s del pin ECHO. \
La funci\'f3n `medir_distancia()` realiza esta secuencia de forma robusta, incorporando tiempos m\'e1ximos de espera (timeouts) tanto para el inicio como para la duraci\'f3n del pulso. \
A partir de la diferencia de tiempos entre los instantes de subida y bajada del eco se calcula la distancia en cent\'edmetros, descartando medidas no v\'e1lidas o demasiado peque\'f1as.\
\
Sobre la medida de distancia se define una l\'f3gica de control basada en una **m\'e1quina de estados finita (FSM) table-driven**. El sistema dispone de tres estados principales:\
\
- `SEGURO`: el obst\'e1culo se encuentra lejos.\
- `ADVERTENCIA`: el obst\'e1culo est\'e1 a una distancia intermedia.\
- `CRITICO`: el obst\'e1culo est\'e1 muy cerca y existe riesgo de colisi\'f3n.\
\
La funci\'f3n `event_parser()` traduce cada distancia en un evento l\'f3gico (`EV_LEJOS`, `EV_CERCA`, `EV_MUY_CERCA`), seg\'fan unos umbrales fijos (10 cm y 15 cm). \
A partir del estado actual y del evento generado, el programa consulta una **tabla de transici\'f3n** (`trans_table`), donde cada combinaci\'f3n estado\'96evento apunta a una funci\'f3n de transici\'f3n concreta. \
Estas funciones ejecutan las acciones asociadas (encendido/apagado de LEDs y control del buzzer) y devuelven el nuevo estado de la FSM.\
\
El interfaz con el usuario se realiza mediante tres LEDs y un zumbador:\
\
- LED verde (`LED_3`) encendido en estado `SEGURO`.\
- LED amarillo (`LED_2`) encendido en estado `ADVERTENCIA`.\
- LED rojo (`LED_1`) encendido en estado `CRITICO`.\
- El buzzer (`BUZZER`) se activa de forma c\'edclica en estado `CRITICO` mediante la funci\'f3n `trans_mantener_critico()`, generando una alarma sonora intermitente.\
\
El bucle principal del programa realiza peri\'f3dicamente la secuencia: medida de distancia \uc0\u8594  generaci\'f3n de evento \u8594  consulta de la tabla de transici\'f3n \u8594  ejecuci\'f3n de la acci\'f3n correspondiente, manteniendo as\'ed una respuesta en tiempo real ante los cambios de proximidad al obst\'e1culo.\
\
### Material utilizado\
\
- **Placa de control**\
  - 1\'d7 Raspberry Pi Pico\
\
- **Sensor**\
  - 1\'d7 Sensor de ultrasonidos HC-SR04  \
    - TRIG conectado al GPIO 16  \
    - ECHO conectado al GPIO 17 (con adaptaci\'f3n a 3,3 V si es necesario)\
\
- **Actuadores**\
  - 1\'d7 LED rojo (indicaci\'f3n estado CRITICO) \'96 GPIO 15  \
  - 1\'d7 LED amarillo (indicaci\'f3n estado ADVERTENCIA) \'96 GPIO 14  \
  - 1\'d7 LED verde (indicaci\'f3n estado SEGURO) \'96 GPIO 13  \
  - 1\'d7 Buzzer 3,3 V (alarma sonora en estado CRITICO) \'96 GPIO 20\
\
- **Elementos auxiliares**\
  - Resistencias limitadoras para cada LED\
  - Protoboard para el montaje del circuito\
  - Cables de conexi\'f3n (jumpers macho\'96macho / macho\'96hembra)\
  - Cable micro-USB para alimentaci\'f3n y programaci\'f3n de la Raspberry Pi Pico\
  - Ordenador para compilaci\'f3n, carga del firmware y monitorizaci\'f3n serie\
}